---
title: "Sync Worker"
description: "Managing the sync worker lifecycle, events, and configuration"
icon: RefreshCw
---

The Sync Worker orchestrates bidirectional synchronization between your IndexedDB and server. It runs periodically, pushing local changes and pulling remote updates.

## Initialization

The sync worker is optional and only created when you enable `outboxSync` in your generator config:

```prisma
generator prismaIDBrowser {
  provider   = "idb-client-generator"
  output     = "../generated"
  outboxSync = true      # Enable sync worker
  rootModel  = "User"
}
```

Initialize the sync worker in your app:

```typescript
import { PrismaIDBClient } from "$lib/prisma-idb";

const client = await PrismaIDBClient.createClient();

// Create the sync worker
const syncWorker = client.createSyncWorker({
  apiUrl: "https://api.example.com",
  push: async (events) => {
    // Send to server
    const response = await fetch(`https://api.example.com/sync/push`, {
      method: "POST",
      body: JSON.stringify({ events }),
    });
    return response.json();
  },
  pull: async (cursor) => {
    // Fetch from server
    const response = await fetch(`https://api.example.com/sync/pull`, {
      method: "POST",
      body: JSON.stringify({ cursor }),
    });
    return response.json();
  },
});

// Start syncing
syncWorker.start();
```

## Configuration

Configure the sync worker behavior:

```typescript
const syncWorker = client.createSyncWorker({
  // API endpoints
  apiUrl: "https://api.example.com",
  push: async (events) => {
    /* ... */
  },
  pull: async (cursor) => {
    /* ... */
  },

  // Timing
  syncInterval: 5000, // ms between sync cycles (default: 5s)
  maxRetries: 3, // max push retries (default: 3)
  retryDelay: 1000, // ms between retries (default: 1s)

  // Behavior
  onError: (error) => {
    console.error("Sync error:", error);
  },
  onSyncStart: () => {
    console.log("Sync started");
  },
  onSyncEnd: () => {
    console.log("Sync completed");
  },
});
```

<Callout type="info">
  **Default Sync Interval**: The worker syncs every 5 seconds. Adjust based on your latency and data freshness needs.
</Callout>

## Lifecycle

### Starting the Worker

```typescript
// Start in the background
syncWorker.start();

// Runs indefinitely until stopped, respecting syncInterval
```

### Manual Sync Cycles

Trigger sync on demand:

```typescript
// Sync immediately without waiting for interval
await syncWorker.sync();

// Useful when:
// - User takes action requiring latest data
// - Network becomes available after offline
// - High-priority updates detected
```

### Stopping the Worker

```typescript
// Stop background sync
syncWorker.stop();

// Waits for current cycle to complete
// Outstanding changes remain in outbox
```

### Status and Monitoring

```typescript
// Check if currently syncing
const isSyncing = syncWorker.isSyncing();

// Get sync state
const state = syncWorker.getState();
console.log({
  isSyncing: state.isSyncing,
  lastSyncTime: state.lastSyncTime,
  nextSyncTime: state.nextSyncTime,
  pendingChanges: state.pendingChanges,
});
```

## Events

The sync worker emits events for reactive UI updates:

```typescript
syncWorker.on("statuschange", (e) => {
  const { status, isLooping, lastSyncTime, lastError } = e.detail;
  console.log(`Status: ${status}, Looping: ${isLooping}`);
  // status: "STOPPED" | "IDLE" | "PUSHING" | "PULLING"
});

syncWorker.on("pushcompleted", (e) => {
  const { results } = e.detail;
  results.forEach((result) => {
    if (result.error) {
      console.error(`Push failed: ${result.error.message}`);
    } else {
      console.log(`Applied: ${result.appliedChangelogId}`);
    }
  });
});

syncWorker.on("pullcompleted", (e) => {
  const { validationErrors, missingRecords, totalAppliedRecords } = e.detail;
  console.log(`Applied ${totalAppliedRecords} records from server`);
  if (validationErrors.length > 0) {
    console.warn(`Validation errors: ${validationErrors.length}`);
  }
});
```

### Real-Time UI Updates

Use events for reactive components:

```svelte
<script lang="ts">
  import { onMount, onDestroy } from "svelte";

  let syncWorker;
  let syncStatus = $state("STOPPED");
  let lastSyncTime = $state<Date>();
  let error = $state("");

  onMount(async () => {
    const client = await PrismaIDBClient.createClient();
    syncWorker = client.createSyncWorker({
      /* ... */
    });

    // Subscribe to status changes
    const unsubscribeStatus = syncWorker.on("statuschange", (e) => {
      syncStatus = e.detail.status;
      if (e.detail.lastError) {
        error = e.detail.lastError.message;
      }
    });

    // Subscribe to push completion
    const unsubscribePushCompleted = syncWorker.on("pushcompleted", (e) => {
      const { results } = e.detail;
      const failed = results.filter((r) => r.error);
      if (failed.length > 0) {
        error = `${failed.length} changes failed to sync`;
      } else {
        error = "";
        lastSyncTime = new Date();
      }
    });

    syncWorker.start();

    // Cleanup on unmount
    return () => {
      syncWorker.stop();
      unsubscribeStatus();
      unsubscribePushCompleted();
    };
  });

  onDestroy(() => {
    if (syncWorker) {
      syncWorker.stop();
    }
  });
</script>

<div class="sync-status">
  {#if syncStatus === "PUSHING" || syncStatus === "PULLING"}
    <span>Syncing...</span>
  {:else if error}
    <span class="error">{error}</span>
  {:else}
    <span>Last synced: {lastSyncTime?.toLocaleString()}</span>
  {/if}
</div>
```

## Offline Behavior

The sync worker handles offline periods gracefully:

```typescript
syncWorker.on("offline", () => {
  console.log("Network unavailable, will retry when back online");
});

syncWorker.on("online", async () => {
  console.log("Network restored, syncing now");
  await syncWorker.sync(); // Immediate sync after reconnection
});
```

All local mutations are queued in the outbox and synced when the network returns:

```typescript
// User offline, making changes
const user = await client.user.create({
  data: { name: "Alice" },
});
console.log("Queued for sync");

// Network returns, worker detects and syncs
// Changes are pushed to server automatically
```

## Error Handling

The sync worker includes retry logic for transient failures:

```typescript
const syncWorker = client.createSyncWorker({
  maxRetries: 5,
  retryDelay: 2000,

  onError: (error) => {
    if (error.code === "NETWORK_ERROR") {
      // Temporary network issue, will retry
      console.log("Network error, retrying...");
    } else if (error.code === "CONFLICT") {
      // Conflict resolution needed
      console.log("Conflict detected:", error.detail);
    } else if (error.code === "UNAUTHORIZED") {
      // Auth failed, user needs to reauthenticate
      window.location.href = "/login";
    }
  },
});
```

## Sync Cycle Flow

```mermaid
sequenceDiagram
  autonumber
  participant Worker
  participant IDB as IndexedDB
  participant API as Server API

  rect rgb(200, 220, 255)
    note over Worker,API: Push Phase
    Worker->>IDB: readOutbox()
    IDB-->>Worker: pending events[]
    Worker->>API: POST /sync/push {events}
    API-->>Worker: {applied, errors}
    Worker->>IDB: markSynced(applied)
    Worker->>IDB: markRetry(errors)
  end

  rect rgb(220, 200, 255)
    note over Worker,API: Pull Phase
    Worker->>IDB: getVersionCursor()
    Worker->>API: POST /sync/pull {cursor}
    API-->>Worker: {changelog, records}
    Worker->>IDB: applyPull(changelog, records)
    Worker->>IDB: advanceCursor()
  end

  Worker-->>Worker: wait(syncInterval)
  Worker->>Worker: loop back to Push
```

## Connection Configuration

### Custom API Implementation

Implement push and pull handlers for your specific API:

```typescript
const syncWorker = client.createSyncWorker({
  push: async (events) => {
    const response = await fetch("/api/sync/push", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        Authorization: `Bearer ${getToken()}`,
      },
      body: JSON.stringify({
        events,
        userId: getCurrentUserId(),
      }),
    });

    if (!response.ok) {
      throw new Error(`Push failed: ${response.statusText}`);
    }

    return response.json();
  },

  pull: async (cursor) => {
    const response = await fetch("/api/sync/pull", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        Authorization: `Bearer ${getToken()}`,
      },
      body: JSON.stringify({
        cursor,
        userId: getCurrentUserId(),
      }),
    });

    if (!response.ok) {
      throw new Error(`Pull failed: ${response.statusText}`);
    }

    return response.json();
  },
});
```

### Batching and Throttling

Control push batch sizes:

```typescript
const syncWorker = client.createSyncWorker({
  push: async (events) => {
    // Process in batches to respect server limits
    const batchSize = 100;
    const results = [];

    for (let i = 0; i < events.length; i += batchSize) {
      const batch = events.slice(i, i + batchSize);
      const result = await fetch("/api/sync/push", {
        method: "POST",
        body: JSON.stringify({ events: batch }),
      }).then((r) => r.json());

      results.push(...result.applied);
    }

    return { applied: results };
  },
});
```

## See Also

- [Outbox Pattern](./outbox) - How mutations are queued
- [Push & Pull Results](./push-pull) - API response formats
- [Validation & Schemas](./validation) - Validating sync data
- [Conflict Resolution](./conflict-resolution) - Handling concurrent changes
