---
title: "Transactions"
description: "Execute multiple operations atomically with transactions"
icon: Lock
---

Transactions ensure multiple operations succeed or fail together, maintaining data consistency even in complex multi-step operations.

## The Basics

A transaction groups operations on one or more IndexedDB stores. If any operation fails, the entire transaction is rolled back.

**Note:** Most operations automatically create a transaction if you don't pass one. Explicitly creating transactions is useful when you need to group multiple operations together atomically.

```typescript
// Create a transaction for 2 stores in read-write mode
const tx = client._db.transaction(["User", "Todo"], "readwrite");

try {
  // Both operations use the same transaction
  const user = await client.user.create(
    { data: { name: "Alice" } },
    { tx }
  );

  await client.todo.create(
    { data: { title: "Task 1", userId: user.id } },
    { tx }
  );

  // Wait for transaction to complete
  await tx.done;
} catch (error) {
  // Automatic rollback on error
  tx.abort();
  throw error;
}
```

## Transaction Modes

### Read-Write

Modify data and read it back:

```typescript
const tx = client._db.transaction(["User", "Profile"], "readwrite");

const user = await client.user.update(
  { where: { id: 1 }, data: { name: "Alice" } },
  { tx }
);

const profile = await client.profile.findUnique(
  { where: { userId: user.id } },
  { tx }
);

await tx.done;
```

### Read-Only

Query multiple stores atomically. Use for complex read operations:

```typescript
const tx = client._db.transaction(["User", "Todo"], "readonly");

const users = await client.user.findMany({}, { tx });
const todos = await client.todo.findMany({}, { tx });

await tx.done;
```

## Composing Transactions

Build reusable transactional operations:

```typescript
async function transferTodo(
  fromUserId: string,
  toUserId: string,
  todoId: string,
  tx?: IDBPTransaction<any, any[], "readwrite">
) {
  const txToUse =
    tx || client._db.transaction(["User", "Todo"], "readwrite");

  try {
    const todo = await client.todo.findUnique(
      { where: { id: todoId } },
      { tx: txToUse }
    );

    if (!todo || todo.userId !== fromUserId) {
      throw new Error("Todo not found or doesn't belong to user");
    }

    await client.todo.update(
      { where: { id: todoId }, data: { userId: toUserId } },
      { tx: txToUse }
    );

    if (!tx) {
      await txToUse.done;
    }
  } catch (error) {
    if (!tx) {
      txToUse.abort();
    }
    throw error;
  }
}

// Use standalone
await transferTodo(user1Id, user2Id, todoId);

// Or nest within larger transaction
const tx = client._db.transaction(
  ["User", "Todo", "AuditLog"],
  "readwrite"
);
await transferTodo(user1Id, user2Id, todoId, tx);
await client.auditLog.create(
  { data: { action: "transfer" } },
  { tx }
);
await tx.done;
```

## Atomicity Guarantees

### Success

All operations complete and persist:

```typescript
const tx = client._db.transaction(["User", "Todo"], "readwrite");

// Both succeed
const user = await client.user.create(
  { data: { name: "Alice" } },
  { tx }
);
const todo = await client.todo.create(
  { data: { title: "Task 1", userId: user.id } },
  { tx }
);

await tx.done; // ✅ Both persisted
```

### Failure

If any operation fails, everything is rolled back:

```typescript
const tx = client._db.transaction(["User", "Todo"], "readwrite");

try {
  const user = await client.user.create(
    { data: { name: "Alice" } },
    { tx }
  );
  
  // This throws because user 999 doesn't exist
  await client.todo.create(
    { 
      data: { 
        title: "Task 1", 
        userId: "999" // Invalid FK
      } 
    },
    { tx }
  );
  
  await tx.done;
} catch (error) {
  tx.abort(); // ❌ User creation was also rolled back
}

// User was NOT created
const users = await client.user.findMany();
console.log(users); // []
```

## Isolation

Transactions provide isolation from other operations:

```typescript
// Transaction 1
const tx1 = client._db.transaction(["User"], "readwrite");
const user = await client.user.create(
  { data: { name: "Alice" } },
  { tx: tx1 }
);

// Transaction 2 - can't see tx1's changes yet
const userBefore = await client.user.findUnique({ where: { id: user.id } });
console.log(userBefore); // null (tx1 not committed yet)

// Commit tx1
await tx1.done;

// Now visible
const userAfter = await client.user.findUnique({ where: { id: user.id } });
console.log(userAfter); // { id, name: "Alice" }
```

## Nested Operations with Transactions

Pass transactions to nested operations:

```typescript
const tx = client._db.transaction(
  ["User", "Profile", "Settings"],
  "readwrite"
);

try {
  const user = await client.user.create(
    {
      data: {
        name: "Alice",
        profile: {
          create: { bio: "New user" },
        },
      },
    },
    { tx }
  );

  await client.settings.create(
    {
      data: {
        userId: user.id,
        theme: "dark",
      },
    },
    { tx }
  );

  await tx.done;
} catch (error) {
  tx.abort(); // All three creations rolled back
  throw error;
}
```

## When to Use Transactions

Transactions are most useful when you need to:

- **Group multiple operations atomically** - Ensure all succeed or all fail together
- **Maintain consistency across models** - Update related records in one atomic step
- **Prevent race conditions** - Isolate operations from concurrent changes

For simple single-model operations, you don't need to create a transaction—the API handles it automatically.

```typescript
// ✅ Good - operation automatically creates transaction
await client.user.create({ data: { name: "Alice" } });

// ✅ Good - explicit transaction for atomicity
const tx = client._db.transaction(["User", "Todo"], "readwrite");
await client.user.create({ data: { name: "Alice" } }, { tx });
await client.todo.create({ data: { title: "Task", userId: userId } }, { tx });
await tx.done;
```

### Scope Minimally

When creating explicit transactions, only include stores you need:

```typescript
// ✅ Good - only the stores we use
const tx = client._db.transaction(["User", "Todo"], "readwrite");

// ❌ Avoid - unnecessary stores
const tx = client._db.transaction(
  ["User", "Todo", "Profile", "Settings", "AuditLog"],
  "readwrite"
);
```

## Error Handling

Always abort on error if not letting it propagate:

```typescript
async function safeTransfer(
  fromId: string,
  toId: string,
  amount: number
) {
  const tx = client._db.transaction(["Account"], "readwrite");

  try {
    const from = await client.account.findUnique(
      { where: { id: fromId } },
      { tx }
    );

    if (!from || from.balance < amount) {
      throw new Error("Insufficient funds");
    }

    await client.account.update(
      {
        where: { id: fromId },
        data: { balance: from.balance - amount },
      },
      { tx }
    );

    const to = await client.account.findUnique(
      { where: { id: toId } },
      { tx }
    );

    await client.account.update(
      {
        where: { id: toId },
        data: { balance: (to?.balance ?? 0) + amount },
      },
      { tx }
    );

    await tx.done;
    return true;
  } catch (error) {
    tx.abort();
    console.error("Transfer failed:", error);
    return false;
  }
}
```

## With Sync

When sync is enabled and you want to group multiple queries atomically, you should include the `OutboxEvent` model in your transaction:

```typescript
const tx = client._db.transaction(
  ["User", "Todo", "OutboxEvent"],
  "readwrite"
);

try {
  await client.user.update(
    { where: { id: 1 }, data: { name: "Alice" } },
    { tx }
  );
  
  // Outbox entry is added in same transaction
  await tx.done;
} catch (error) {
  tx.abort();
  throw error;
}
```

**Note:** Single operations automatically include `OutboxEvent` internally if you don't pass a transaction, so you only need to explicitly include it when using explicit transactions.

## ⚠️ Important: Async Operations in Transactions

IndexedDB transactions will **immediately close** if you await any async operation that isn't a database query. Once closed, any further database operations fail.

```typescript
// ❌ WRONG - Transaction closes while awaiting the API call
const tx = client._db.transaction(["User", "Todo"], "readwrite");
const user = await client.user.findUnique({ where: { id: 1 } }, { tx });
const userData = await fetch(`/api/user/${user.id}`).then(r => r.json()); // ❌ Tx closed!
await client.user.update({ where: { id: 1 }, data: userData }, { tx }); // ❌ Fails
```

**Best practices:**

1. **Use nested queries and includes** to fetch related data in one operation:

```typescript
// ✅ CORRECT - All data fetched in one query
const user = await client.user.findUnique({
  where: { id: 1 },
  include: { profile: true, todos: true },
});
```

2. **Use filters instead of client-side filtering**:

```typescript
// ✅ CORRECT - Filter happens in database
const activeTodos = await client.todo.findMany({
  where: { userId: 1, done: false },
});

// ❌ WRONG - If inside transaction, it closes before filtering completes
const allTodos = await client.todo.findMany({ where: { userId: 1 } });
const activeTodos = allTodos.filter(t => !t.done);
```

3. **Do async work before or after transactions**:

```typescript
// ✅ CORRECT
const externalData = await fetch("/api/data").then(r => r.json());

const tx = client._db.transaction(["User"], "readwrite");
await client.user.update({
  where: { id: 1 },
  data: externalData,
}, { tx });
await tx.done;
```
